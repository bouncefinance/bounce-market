## Bounce NFT API Interface Document

### 一、Platform consensus

#### 1.1 MateData

> NFTs generated within the platform, whether ERC-721 or ERC-1155, follow the following MATEDATE format

```json
{
    "id":{	// NFT's unique tokenID
    	type: int,
    	require: true,
    	value: 16944
    },
    "brandid":{		// For the brand ID of item, bounce721 corresponds to 10, and bounce1155 corresponds to 11
    	type: int,
    	reqiure: true,
    	value: 10
    },
    "contractaddress":{	// NFT Contract address
    	type: String(address),
    	require: true,
    	value: "0x..."
    },
    "metadata":"",
    "category":{	// gategory（Image, video, audio...）
    	type: String,
    	require: true,
    	defaule: 'image'
    	value: ""
    },
    "channel":{		// channel（Fine Arts, sports, Comic Books...）
    	type: String,
    	require: true,
    	defaule: 'Fine Arts'
    	value: ""
    },
    "itemsymbol":{		// NFT Symbol 
    	type: String,
    	require: true,
    	value: ""
    },
    "standard":{	// NFT stadard， 1: ERC-721 2: ERC-1155
    	type: Int,
    	require: true,
    	value: 1  
    },
    "itemname":{	// NFT Name 
    	type: String,
    	require: true,
    	value: ''
    },
    "externallink":{	// externallink
    	type: String(link),
    	require: false,
    	value: ""
    },
    "description":{		// NFT description
    	type: String, 
    	require: true,
    	maxLength: 300,
    	value: '721_1'
    },
    "fileurl":{		// NFT Online links to file previews, usually online images, audio, video, etc., for display
    	type: String(link),
    	require: true,
    	value: ''
    },
    "properties":{
    	type: String,
    	require: false,
    	value: ""
    },
    "levels":{
    	type: String,
    	require: false,
    	value: ""
    },
    "stats":{	
    	type: String,
    	require: false,
    	value: ""
    },
    "unlockablecontent":{
    	type: String,
    	require: false,
    	value: ""
    },
    "supply":{		// supply，721 defaults to 1, and 1155 is customizable
    	type: Int,
    	require: true,
    	value: ""
    },
    "ownername":{
    	type: String,
    	require: false,
    	value: ""
    },
    "owneraddress":{	// The owner's wallet address, the owner's administrator for this NFT
    	type: String(address),
    	require: true,
    	value: ""
    },
    "status":{
    	type: String,
    	require: false,
    	value: ""
    },
    "created_at":{		// Create a timestamp for the moment
    	type: Timestamp,
    	require: true,
    	value: ""
    },
    "updated_at":{	// The timestamp of the last time the information was changed
    	type: Timestamp,
    	require: true,
    	value: ""
    }
  }
```

#### 1.2 Account Format

```json
{
    "accountaddress": {	
        type: String(address),
        require: true,
        value: '0x...'
    },
    bandimgurl: {	// Online link to Brand's background image
        type: String(link),
        require: false,
        value: 'https://...'
    },
    bio: {		// A sentence describing yourself
        type: String,
        require: false,
        value: ''
    },
    email: {
        type: String(email),	// email
        require: true,
        value: '...@...'
    },
    fullname: {	
        type: String,
        require: true,
        value: ''
    },
    imgurl: {
        type: String(link),
        require: true,
        value: 'https://...'
    },
    username: {	
        type: String,
        require: true,
        value: ''
    }
}
```

#### 1.3 Brand in the format

```json
{
  "brandname": {
      type: String,
      require: true, 
      value: ''
  },
  "brandsymbol":  {		// All NFT Symbol created within the brand
      type: String,
      require: true, 
      value: ''
  },
  "contractaddress":  {	// The address of the subcontract generated by invoking the factory contract
      type: String,
      require: true, 
      value: ''
  },
  "description":  {	// Brand description
      type: String,
      require: true, 
      value: ''
  },
  "imgurl": {	// links to brand covers
      type: String,
      require: true, 
      value: ''
  },
  "owneraddress": {	// The address of the brand founder
      type: String,
      require: true, 
      value: ''
  },
  "ownername": {	// The user name of the brand creator
      type: String,
      require: true, 
      value: ''
  },
  "standard": {		//  1、ERC-721 , 2、ERC-1155
      type: String,
      require: true, 
      value: ''
  },
  "status":{
      type: String,
      require: true, 
      value: ''
  },
}
```







### 二、Basic operation

Swagger UI Summary of interface documents：[网页链接](https://market-test.bounce.finance/swagger/index.html)

BaseHost: 

- Binance Smart Chain: https://bounce-market.bounce.finance

- Rinkeby (https):  https://bounce-market.bounce.financ
- Rinkeby (http):  https://market-test.bounce.finance

#### 2.1 Create and use signatures

**Create signatures**

> The JWT signature is generated from the MateMask signature. Before using this interface, you must first get the MateMask signature data

```jsx
# POST
# /api/v2/main/jwtauth

const sign = await web3.eth.personal.sign(signStr, account)

const params = {
            "accountaddress": account,
            "message": signStr,
            "signature": sign
        }

const res_getSignToken = await axios.post(Base_URL + '/api/v2/main/jwtauth', params)
    if (res_getSignToken.status === 200 && res_getSignToken.data.code === 200) {
        const { token } = res_getSignToken.data.data
        return token
    }
```

**使用签名**

> All interfaces must take an 'AccountAddress' parameter, passing in the address of the user's signature.
> If the address and signature do not match, an error is returned

```jsx
const token = await getSignToken()
const config = {
    headers:{
        token: token
    }
}

const params = {
    accountaddress: account,	// Each interface must be transmitted
    ...
}

axios.post(Base_URL + '/api/v2/main/...', params, config)
```

**The status returned by the signature **

- code = 1:  Correct return information
- code = -1 && msg='jwt error': The request sent does not carry a token, or the signature does not match the current account



#### 2.2 Create and use NFT

**Create NFT**

> First, you need to access the MateData package to the back end, which returns the signature

```jsx
# POST
# /api/v2/main/auth/additem

const params = {
    "accountaddress": account,
    ... // Here fill in the corresponding field information in NFT MateData format
    // See 1.1 MateData format for details
}
    
    
return result = {	// All three values returned are needed in the contract
            expiredtime: 1617444595,		//  The time stamp
            id: 17139	// token ID
            signaturestr:  // A string signed by the administrator account"0x0cfe6b4fd1407c9a9f6e860fb5b323da85e2f0234f3077c619d5bbeab32286836595a52e39db04348ddee5ba5d03c62c49983bfcc1135e3053cc0f3fe153f42c1b"
        }
```



**Query for NFT information about the specified ID**

> Single query: Since most of the platform's MateData exists on a back-end server and the NFT ID is generated by the back-end, most interfaces only need to pass in the NFT ID to query the MateDate information

```jsx
# POST
# /api/v2/main/auth/getoneitembyid

const params = {
    "accountaddress": account,
    "id": 10086
}

const result = {
    // Returns a data object in matedata format, as shown in the figure below
}
```

![image-20210403174431080](http://yitian-2020.oss-cn-shenzhen.aliyuncs.com/img/image-20210403174431080.png)

> Batch query: There are many cases where you need to batch query the NFT ID Matedata situation. In this case, you can use the batch query method. You can also pass in the classification parameter for the classification query

```jsx
# POST
# /api/v2/main/auth/getitemsbyids

const params = {
    "accountaddress": account,
    "ids": [10086, 10010],
    "category": "Image",	// optional
  	"channel": "Fine Arts",		// optional
}

const result = {
    // Returns an array of data in the format described above
}
```



#### 2.3 File upload

> The media resource file used by the platform is saved by the back-end server. After the file binary is transferred to the back-end, the back-end interface will return an online reference link, which will be used in many places

**Get the file binary data, with the file preview**

```jsx
// Gets the binary file data for the image
 const handelFileChange = (e) => {
        const file = e.target.files[0]
        // console.log(file)
        if (!file) return
        if (file.type === 'image/png' || file.type === 'image/jpg'|| file.type === 'image/jpeg' || file.type === 'image/gif') {
            let reader = new FileReader();  //call FileReader
            reader.readAsDataURL(file); //Read the file as DataURL(base64)
            reader.onload = function (evt) {   //Fired when the read operation completes
                setCoverSrc(evt.target.result)  //Bind the SRC of the img tag to dataURL
                setInfoTitle(file.name)
            }
            let formData = new FormData()
            formData.append('filename', file)
            onFileChange && onFileChange(formData, file)
            // setFormData(formData)
        } else {
            dispatch({ type: 'Modal_Message', showMessageModal: true, modelType: 'error', modelMessage: "The file format you selected is incorrect" });
        }
    }

```

**Upload the file stream **

```jsx
# POST
# /api/v2/main/auth/fileupload

const res = await sign_Axios.post('/api/v2/main/auth/fileupload', fileData, { appendAccount: false })
                if (res.data.code === 200) {
                    imgUrl = res.data.result.path
                }
// The imgUrl here is the online link that is returned

```



#### 2.4 Account information

> 本平台内嵌一个用户系统，主要用到了以下的一些接口

**Upload account information**

```jsx
# POST
# /api/v2/main/auth/addaccount

const params = {
    accountaddress: account,
    // See 1.2 Format of Account Information for details
}

const res = {
    code === 1: success
    code !== 0: error
}
```

**Query account information**

```jsx
# POST
# /api/v2/main/auth/addaccount

const params = {
    accountaddress: account
}

const res = {
    // Case 1: return correctly
    Return the account data in accordance with 1.2 account information format, and display it as information

	// Case 2: The requested account does not exist
    After entering the platform, the user only needs to connect the wallet, and the wallet address is the identity token, and the user can choose whether to complete the account information according to his/her will
    When return {code: 0&&msg: "Record of AccountAddress is not existed."}
The request was made on behalf of the server, but the user did not complete the user information
}
```

**Update account information**

> You can update the information of the specified account through this interface, but only the fields listed below. The rest of the fields cannot be changed at will

```jsx
# POST
# /api/v2/main/auth/updateaccount

const param = {
    accountaddress :account,	// User address as an index field	
    username : '',	
    imgurl :'',		// The avatars
    email :'',		// User E-mail
    bio :''			
}

return result = {
    code === 1: success
    code !== 0: error
}

```

**If the fullName of the user exists **

> In the platform account system design, the FULLNAME field is unique, so it is necessary to determine whether the FULLNAME field is occupied before adding or modifying it

```jsx
# POST
# /api/v2/main/auth/getaccountname

const param = {
    accountaddress :account,	// Account address as an index field
    fullname : '',	
}

return result = {
    code === 1: success
    code !== 0: error
}

```

**Other**

```jsx
# POST
# /api/v2/main/auth/updateaccountbandimg
Update the user's band image information based on Address
```



#### 2.5 Brand operation

> Brand system is a feature of the platform. Users can create a brand in the platform (currently, each user can only create one brand). After successful creation, the factory contract will generate a corresponding sub-contract, which can carry out a series of platform NFT operations

**Create brand**

```jsx
# POST
# /api/v2/main/auth/addbrand

const params = {
    accountaddress :account,
    ... // 1.3 Brand in the format
}
    
return result = {
    code === 1: success
    code !== 0: error
}
```

**更新brand**

> 可以通过此接口更新指定brand id 的brand 信息，但是仅限于以下几种列出的字段，其余字段不得随意修改

```jsx
# POST
# /api/v2/main/auth/updatebrandbyid

const param = {
  "accountaddress": "string",
  "brandname": "string",
  "description": "string",
  "id": 0,
  "imgurl": "string",
  "ownername": "string"
}

return result = {
    code === 1: success
    code !== 0: error
}
```

**Update the brand background image**

```jsx
# POST
# /api/v2/main/auth/updatebandimg

const param = {
  "accountaddress": "string",
  "bandimgurl": "string",	// Update the background image's online link
  "id": 0
}

return result = {
    code === 1: success
    code !== 0: error
}
```





**Obtain brand information**

Gets a list of all brands created by a single user

```jsx
# POST
# /api/v2/main/auth/getaccountbrands

const params = {
    accountaddress : account
}

return result = {
    [brandArray] // Brand Information List
}
```



Single query: Gets the brand created by ID

```jsx
# POST
# /api/v2/main/auth/getbrandbyid

const params = {
    accountaddress : account, 
    id: 1 // brandID
}

return result = {
    Returns the brand details of the corresponding ID 
}
```

![image-20210403195321417](http://yitian-2020.oss-cn-shenzhen.aliyuncs.com/img/image-20210403195321417.png)



Bulk query: Get the brands created according to ID

```jsx
# POST
# /api/v2/main/auth/getbrandsbyfilter

const params = {
    accountaddress : account, 
    "brandcontractaddressess": [
        "0x1...", "0x2..."
     ],
    Category: String,	// optional
    channel: String	// optional
}

return result = {
    Returns a detailed list of brands corresponding to the ID list
}
```

**other**

> To get the Popular Brands information on the first page, this interface returns 6 brands and needs to filter the NFT of Brandid === 10 and Brandid === 11 of the bounce platform itself. These two brands are not included in the ranking

```jsx
# POST
# /api/v2/main/auth/getpopularbrands

const params = {
    accountaddress: account
}

return result = Array(4){
    // Brand Information List
}
```



#### 2.6 Like Item

> When browsing the market, users can add the items they are interested in to Like or cancel the items they were interested in before, and the items they have collected can be viewed in My Like

**添加挂单**

```jsx
# POST
# /api/v2/main/auth/dealaccountlike

const params = {
  "accountaddress": "string",	// Index by user account
  "auctiontype": 0,		// The type of item being sold，0：fixed-swap 1：english-auction
  "brandid": 0,		// Item corresponds to the ID of the brand
  "iflike": 0,	// 	Whether like 0: Cancel the like 1：like
  "itemid": 0,	//  item id
  "poolid": 0
}


return result = {
    code === 1: success
    code !== 0: error
}
```

**Get a list of like**

```jsx
# POST
# /api/v2/main/auth/getaccountlike


const params = {
  "accountaddress": "string"
}

const result = Array( lenght ){
    // A list of item information for like
}
```



### 三、Contract operation

#### 3.1 Create ERC - 721

> To cast an ERC-721 NFT, a number of steps are required, requiring the cooperation of the back end and the contract end.
> This applies to GenRate NFT and Add Brand Item NFT
>
> To create ERC-721, call Backend 2.2 to generate MATedata data in format

Upon successful MateData generation, the back-end interface returns the three required fields

- expiredtime：A timestamp that reflects the time 10 minutes later	
- id: NFT Token ID
- signaturestr: An encrypted string signed by an administrator account on the back end

```jsx
const BounceERC721WithSign_CT = getContract(library, BounceERC721WithSign.abi, getBounceERC721WithSign(chainId))

try {
	BounceERC721WithSign_CT.methods.mintUser(_nftId, _sign, _expiredtime).send({ from: account })
        .on('transactionHash', hash => {
            setOpen(false)
            // setBidStatus(pendingStatus)
            showTransferByStatus('pendingStatus')
        })
        .on('receipt', async (_, receipt) => {
            // console.log('bid fixed swap receipt:', receipt)
            // setBidStatus(successStatus)
            showTransferByStatus('successStatus')
            history.push("/MyBrands")
        })
        .on('error', (err, receipt) => {
            // setBidStatus(errorStatus)
            showTransferByStatus('errorStatus')
        })
} catch (error) {
    console.log('BounceERC721_CT.methods.mintUser', error)
}

```

#### 3.2 Create ERC - 1155

> ERC-1155 is created with several more parameters than ERC-721, and ERC-1155 has several special properties. This also applies to GenRate NFT and Add Brand Item NFT
>
> To create ERC-1155, call Backend 2.2 to generate MATEDATA data in the format

- expiredtime：A timestamp that reflects the time 10 minutes later
- id: NFT Token ID
- signaturestr: An encrypted string signed by an administrator account on the back end
- _data：NFT data, can pass 0 by default
- _amount：1155 relative to 721 is the concept of quantity, here pass the number （supply）of casting

```jsx
const BounceERC1155WithSign_CT = getContract(library, BounceERC1155WithSign.abi, getBounceERC1155WithSign(chainId))
const _amount = formData.Supply
const _data = 0 

try {
    BounceERC1155WithSign_CT.methods.mintUser(_nftId, _amount, _data, _sign,_expiredtime).send({ from: account })
        .on('transactionHash', hash => {
            setOpen(false)
            // setBidStatus(pendingStatus)
            showTransferByStatus('pendingStatus')
        })
        .on('receipt', async (_, receipt) => {
            // console.log('bid fixed swap receipt:', receipt)
            // setBidStatus(successStatus)
            showTransferByStatus('successStatus')
            history.push("/MyBrands")
        })
        .on('error', (err, receipt) => {
            // setBidStatus(errorStatus)
            showTransferByStatus('errorStatus')
        })
} catch (error) {
    console.log('BounceERC1155_CT.methods.mintUser', error)
}
```

#### 3.3 Create a subcontract in the Factory

> Factory can generate sub-contracts for each brand, and these sub-contracts have the same functions as Bounce NFT contracts, which can be cast, transferred, sold, etc...

**Create ERC-721 subcontract**

```jsx
const Factory_CT = getContract(library, BounceNFTFactory.abi, getNFTFactory(chainId))

Factory_CT.methods.createBrand721(_name, _symbol).send({ from: account })
```

- _name: Uniform name for the NFT cast
- _symbol: The NFT uniform symbol cast

**Create the ERC-1155 subcontract**

> The ERC-1155 contract does not have the concept of name and symbol, so it only needs to pass a baseURL

```jsx
const Factory_CT = getContract(library, BounceNFTFactory.abi, getNFTFactory(chainId))

Factory_CT.methods.createBrand1155(_uri).send({ from: account })
```



#### 3.4 Fixed-swap

##### a ) Selling the ERC - 721

> The essence of the sales operation is that the NFT in the account needs to be managed into the contract, and the Approve operation needs to be carried out first at this time

**approve**

```jsx
BounceERC721WithSign_CT.methods.approve(
    getFixedSwapNFT(chainId),
    parseInt(_tokenId)
).send({ from: account });
```

**send**

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))

BounceFixedSwapNFT_CT.methods.createErc721(_name, _token0, _token1, _tokenId, _amountTotal1, _onlyBot).send({ from: account })
```

- _name: NFT name
- _token0:   The contract address of the NFT for sale
- _token1:  The contract address of the collection subject (ETH, BNB) is 0x000...000).
- _tokenId: NFT ID for sale
- _amountTotla1: The selling price, and the units are token1 symbols
- _onlyBot: Is the participant a BOT (AUCTION) holder

##### b ) Selling the ERC - 1155

**approve**

```jsx
BounceERC1155WithSign_CT.methods.setApprovalForAll(
    getFixedSwapNFT(chainId),
    true
).send({ from: account });
```

**send**

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))

BounceFixedSwapNFT_CT.methods.createErc1155(_name, _token0, _token1, _tokenId, _amountTotal0,_amountTotal1, _onlyBot)
.send({ from: account })
```

- _name: NFT name
- _token0:   The contract address of the NFT for sale
- _token1:  The contract address of the collection subject (ETH, BNB) is 0x000...000).

- _tokenId: NFT ID for sale
- _amountTotal0: Number of NFTs to sell
- _amountTotla1: The total selling price, in symbols of Token 1
- _onlyBot: Is the participant a BOT (AUCTION) holder

##### c ) Buying Common Methods

> The pool ID is indexed from 0. The pool ID increases with each additional sales order in the fixed-swap pool. The pool ID is equal to the order number

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))


BounceFixedSwapNFT_CT.methods.swap(poolId, _amountTotal0)
.send(sendParams)
```

- poolId：The pool ID corresponding to the transaction
- _amountTotal0: The number of NFT to be purchased (the quantity of ERC-721 can only be 1, and ERC-1155 can be purchased in multiple times)

##### d ) Eliminate the common method of selling

> Fixed - Swap supports sellers to cancel the sale halfway

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))


BounceFixedSwapNFT_CT.methods.cancel(poolId)
.send(sendParams)
```

- pool Id：The pool ID corresponding to the transaction





#### 3.5 English-Auction

##### a ) General method of selling

**approve**

> If it is non-ETH, the base currency of BNB is used as the payment currency, which needs to be approved before consumption, and the platform adopts one-time authorization

```jsx
 const BounceERC20_CT = getContract(library, BounceERC20.abi, poolInfo.token1.contract)

BounceERC20_CT.methods.approve(getFixedSwapNFT(chainId), '0xffffffffffffffff')
.send({ from: account })
```



**send**

```jsx
const BounceEnglishAuctionNFT_CT = getContract(library, BounceEnglishAuctionNFT.abi, getEnglishAuctionNFT(chainId))

BounceEnglishAuctionNFT_CT.methods.createErc721(_name, _token0, _token1, _tokenId,
						_amountMax1, _amountMin1, _amountMinIncr1, _amountReserve1, _duration, _onlyBot).send({ from: account })
```

- name: NFT name
- _token0:   The contract address of the NFT for sale
- _token1: The contract address of the collection subject (ETH, BNB) is 0x000...000).

- _amountMax1: Direct Purchase Price, where the buyer can buy the item directly at the Price of one bid, bypassing the auction
- _amountMin1: Minimum Bid,The starting price of the item
- _amountMinIncr1: The lowest range of each mark-up
- _amountReserve1：Reserve price, the final bidding price is lower than this price will flow to auction
- _duration：Expriration Date
- _onlyBot:  Is the participant a BOT (AUCTION) holder



##### b ) General Method of Bidding

**approve**

> If it is non-ETH, the base currency of BNB is used as the payment currency, which needs to be approved before consumption, and the platform adopts one-time authorization

```jsx
 const BounceERC20_CT = getContract(library, BounceERC20.abi, poolInfo.token1.contract)

BounceERC20_CT.methods.approve(getFixedSwapNFT(chainId), '0xffffffffffffffff')
.send({ from: account })
```

**send**

> If a user's bid is higher than the lowest price range of the previous bid during the auction duration (higher than the starting price for the first time) and the price is less than the one bid price, it is a normal bidding action.
> At the end of the auction, if the highest bid is higher than the reserve price, the bid is successful.
> If it falls below the reserve price, it is a lost bid.
>
> Or, of course, you can just buy it at one price and skip the auction, and you end up with the pool.
>
> This auction method ERC-1155 does not support bidding by quantity, but can only be purchased in packages

```jsx
const BounceEnglishAuctionNFT_CT = getContract(library, BounceEnglishAuctionNFT.abi, getEnglishAuctionNFT(chainId))

BounceEnglishAuctionNFT_CT.methods.bid(poolId, _amount1)
.send(sendParams)
```

- pool Id：The pool ID corresponding to the transaction
- _amountTotal1: bid price

##### c ) Seller claim

> The item is successfully auctioned and the seller can take back the ERC-20 token paid by the buyer
>
> Items lost auction: The seller retrieves the NFT sold

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))


BounceFixedSwapNFT_CT.methods.bidderClaim(poolId)
.send(sendParams)
```

- pool Id：The pool ID corresponding to the transaction

##### d ) Buyers claim

> Successful bid: the buyer receives the NFT
>
> Auction failure: For example, if the bid does not reach the seller's reserve price, you can get your ERC-20 tokens back after the auction

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))

BounceFixedSwapNFT_CT.methods.creatorClaim(poolId)
.send(sendParams)
```



### 四、The Graph

> Details see the DEMO

