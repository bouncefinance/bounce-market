## Bounce NFT API Interface Document

### 一、Platform consensus

#### 1.1 MateData

> NFTs generated within the platform, whether ERC-721 or ERC-1155, follow the following MATEDATE format

```json
{
    "id":{	// NFT's unique tokenID
    	type: int,
    	require: true,
    	value: 16944
    },
    "brandid":{		// For the brand ID of item, bounce721 corresponds to 10, and bounce1155 corresponds to 11
    	type: int,
    	reqiure: true,
    	value: 10
    },
    "contractaddress":{	// NFT Contract address
    	type: String(address),
    	require: true,
    	value: "0x..."
    },
    "metadata":"",
    "category":{	// gategory（Image, video, audio...）
    	type: String,
    	require: true,
    	defaule: 'image'
    	value: ""
    },
    "channel":{		// channel（Fine Arts, sports, Comic Books...）
    	type: String,
    	require: true,
    	defaule: 'Fine Arts'
    	value: ""
    },
    "itemsymbol":{		// NFT Symbol 
    	type: String,
    	require: true,
    	value: ""
    },
    "standard":{	// NFT stadard， 1: ERC-721 2: ERC-1155
    	type: Int,
    	require: true,
    	value: 1  
    },
    "itemname":{	// NFT Name 
    	type: String,
    	require: true,
    	value: ''
    },
    "externallink":{	// externallink
    	type: String(link),
    	require: false,
    	value: ""
    },
    "description":{		// NFT description
    	type: String, 
    	require: true,
    	maxLength: 300,
    	value: '721_1'
    },
    "fileurl":{		// NFT Online links to file previews, usually online images, audio, video, etc., for display
    	type: String(link),
    	require: true,
    	value: ''
    },
    "properties":{
    	type: String,
    	require: false,
    	value: ""
    },
    "levels":{
    	type: String,
    	require: false,
    	value: ""
    },
    "stats":{	
    	type: String,
    	require: false,
    	value: ""
    },
    "unlockablecontent":{
    	type: String,
    	require: false,
    	value: ""
    },
    "supply":{		// supply，721 defaults to 1, and 1155 is customizable
    	type: Int,
    	require: true,
    	value: ""
    },
    "ownername":{
    	type: String,
    	require: false,
    	value: ""
    },
    "owneraddress":{	// The owner's wallet address, the owner's administrator for this NFT
    	type: String(address),
    	require: true,
    	value: ""
    },
    "status":{
    	type: String,
    	require: false,
    	value: ""
    },
    "created_at":{		// Create a timestamp for the moment
    	type: Timestamp,
    	require: true,
    	value: ""
    },
    "updated_at":{	// The timestamp of the last time the information was changed
    	type: Timestamp,
    	require: true,
    	value: ""
    }
  }
```

#### 1.2 Account Format

```json
{
    "accountaddress": {	
        type: String(address),
        require: true,
        value: '0x...'
    },
    bandimgurl: {	// Online link to Brand's background image
        type: String(link),
        require: false,
        value: 'https://...'
    },
    bio: {		// A sentence describing yourself
        type: String,
        require: false,
        value: ''
    },
    email: {
        type: String(email),	// email
        require: true,
        value: '...@...'
    },
    fullname: {	
        type: String,
        require: true,
        value: ''
    },
    imgurl: {
        type: String(link),
        require: true,
        value: 'https://...'
    },
    username: {	
        type: String,
        require: true,
        value: ''
    }
}
```

#### 1.3 Brand in the format

```json
{
  "brandname": {
      type: String,
      require: true, 
      value: ''
  },
  "brandsymbol":  {		// All NFT Symbol created within the brand
      type: String,
      require: true, 
      value: ''
  },
  "contractaddress":  {	// The address of the subcontract generated by invoking the factory contract
      type: String,
      require: true, 
      value: ''
  },
  "description":  {	// Brand description
      type: String,
      require: true, 
      value: ''
  },
  "imgurl": {	// links to brand covers
      type: String,
      require: true, 
      value: ''
  },
  "owneraddress": {	// The address of the brand founder
      type: String,
      require: true, 
      value: ''
  },
  "ownername": {	// The user name of the brand creator
      type: String,
      require: true, 
      value: ''
  },
  "standard": {		//  1、ERC-721 , 2、ERC-1155
      type: String,
      require: true, 
      value: ''
  },
  "status":{
      type: String,
      require: true, 
      value: ''
  },
}
```







### 二、Basic operation

Swagger UI Summary of interface documents：[网页链接](https://market-test.bounce.finance/swagger/index.html)

BaseHost:

- Binance Smart Chain: https://bounce-market.bounce.finance

- Rinkeby (https):  https://bounce-market.bounce.finance
- Rinkeby (http):  https://market-test.bounce.finance

#### 2.1 Create and use signatures

**Create signatures**

> The JWT signature is generated from the MateMask signature. Before using this interface, you must first get the MateMask signature data

```jsx
# POST
# /api/v2/main/jwtauth

const sign = await web3.eth.personal.sign(signStr, account)

const params = {
            "accountaddress": account,
            "message": signStr,
            "signature": sign
        }

const res_getSignToken = await axios.post(Base_URL + '/api/v2/main/jwtauth', params)
    if (res_getSignToken.status === 200 && res_getSignToken.data.code === 200) {
        const { token } = res_getSignToken.data.data
        return token
    }
```

**使用签名**

> All interfaces must take an 'AccountAddress' parameter, passing in the address of the user's signature.
> If the address and signature do not match, an error is returned

```jsx
const token = await getSignToken()
const config = {
    headers:{
        token: token
    }
}

const params = {
    accountaddress: account,	// Each interface must be transmitted
    ...
}

axios.post(Base_URL + '/api/v2/main/...', params, config)
```

**The status returned by the signature **

- code = 1:  Correct return information
- code = -1 && msg='jwt error': The request sent does not carry a token, or the signature does not match the current account



#### 2.2 *Create and use NFT

**Create NFT**

> First, you need to access the MateData package to the back end, which returns the signature

```jsx
# POST
# /api/v2/main/auth/additem

const params = {
    "accountaddress": account,
    ... // Here fill in the corresponding field information in NFT MateData format
    // See 1.1 MateData format for details
}
    
    
return result = {	// All three values returned are needed in the contract
            expiredtime: 1617444595,		//  The time stamp
            id: 17139	// token ID
            signaturestr:  // A string signed by the administrator account"0x0cfe6b4fd1407c9a9f6e860fb5b323da85e2f0234f3077c619d5bbeab32286836595a52e39db04348ddee5ba5d03c62c49983bfcc1135e3053cc0f3fe153f42c1b"
        }
```



**Query for NFT information about the specified ID**

> Single query: Since most of the platform's MateData exists on a back-end server and the NFT ID is generated by the back-end, most interfaces only need to pass in the NFT ID to query the MateDate information

***<u>Update: Add ct field, pass in NFT contract address</u>***

```jsx
# POST
# /api/v2/main/auth/getoneitembyid

const params = {
    "accountaddress": account,
    "id": 10086,
    "ct": '0x...',	// add：NFT Contract address
}

const result = {
    // Returns a data object in matedata format, as shown in the figure below
}
```

![image-20210403174431080](http://yitian-2020.oss-cn-shenzhen.aliyuncs.com/img/image-20210403174431080.png)

> Batch query: There are many cases where you need to batch query the NFT ID Matedata situation. In this case, you can use the batch query method. You can also pass in the classification parameter for the classification query

```jsx
# POST
# /api/v2/main/auth/getitemsbyids

const params = {
    "accountaddress": account,
    "ids": [10086, 10010],
    "category": "Image",	// optional
  	"channel": "Fine Arts",		// optional
}

const result = {
    // Returns an array of data in the format described above
}
```



#### 2.3 File upload

> The media resource file used by the platform is saved by the back-end server. After the file binary is transferred to the back-end, the back-end interface will return an online reference link, which will be used in many places

**Get the file binary data, with the file preview**

```jsx
// Gets the binary file data for the image
 const handelFileChange = (e) => {
        const file = e.target.files[0]
        // console.log(file)
        if (!file) return
        if (file.type === 'image/png' || file.type === 'image/jpg'|| file.type === 'image/jpeg' || file.type === 'image/gif') {
            let reader = new FileReader();  //call FileReader
            reader.readAsDataURL(file); //Read the file as DataURL(base64)
            reader.onload = function (evt) {   //Fired when the read operation completes
                setCoverSrc(evt.target.result)  //Bind the SRC of the img tag to dataURL
                setInfoTitle(file.name)
            }
            let formData = new FormData()
            formData.append('filename', file)
            onFileChange && onFileChange(formData, file)
            // setFormData(formData)
        } else {
            dispatch({ type: 'Modal_Message', showMessageModal: true, modelType: 'error', modelMessage: "The file format you selected is incorrect" });
        }
    }

```

**Upload the file stream **

```jsx
# POST
# /api/v2/main/auth/fileupload

const res = await sign_Axios.post('/api/v2/main/auth/fileupload', fileData, { appendAccount: false })
                if (res.data.code === 200) {
                    imgUrl = res.data.result.path
                }
// The imgUrl here is the online link that is returned

```



#### 2.4 Account information

> 本平台内嵌一个用户系统，主要用到了以下的一些接口

**Upload account information**

```jsx
# POST
# /api/v2/main/auth/addaccount

const params = {
    accountaddress: account,
    // See 1.2 Format of Account Information for details
}

const res = {
    code === 1: success
    code !== 0: error
}
```

**Query account information**

```jsx
# POST
# /api/v2/main/auth/addaccount

const params = {
    accountaddress: account
}

const res = {
    // Case 1: return correctly
    Return the account data in accordance with 1.2 account information format, and display it as information

	// Case 2: The requested account does not exist
    After entering the platform, the user only needs to connect the wallet, and the wallet address is the identity token, and the user can choose whether to complete the account information according to his/her will
    When return {code: 0&&msg: "Record of AccountAddress is not existed."}
The request was made on behalf of the server, but the user did not complete the user information
}
```

**Update account information**

> You can update the information of the specified account through this interface, but only the fields listed below. The rest of the fields cannot be changed at will

```jsx
# POST
# /api/v2/main/auth/updateaccount

const param = {
    accountaddress :account,	// User address as an index field	
    username : '',	
    imgurl :'',		// The avatars
    email :'',		// User E-mail
    bio :''			
}

return result = {
    code === 1: success
    code !== 0: error
}

```

**If the fullName of the user exists **

> In the platform account system design, the FULLNAME field is unique, so it is necessary to determine whether the FULLNAME field is occupied before adding or modifying it

```jsx
# POST
# /api/v2/main/auth/getaccountname

const param = {
    accountaddress :account,	// Account address as an index field
    fullname : '',	
}

return result = {
    code === 1: success
    code !== 0: error
}

```

**Other**

```jsx
# POST
# /api/v2/main/auth/updateaccountbandimg
Update the user's band image information based on Address
```



#### 2.5 Brand operation

> Brand system is a feature of the platform. Users can create a brand in the platform (currently, each user can only create one brand). After successful creation, the factory contract will generate a corresponding sub-contract, which can carry out a series of platform NFT operations

**Create brand**

```jsx
# POST
# /api/v2/main/auth/addbrand

const params = {
    accountaddress :account,
    ... // 1.3 Brand in the format
}
    
return result = {
    code === 1: success
    code !== 0: error
}
```

**更新brand**

> 可以通过此接口更新指定brand id 的brand 信息，但是仅限于以下几种列出的字段，其余字段不得随意修改

```jsx
# POST
# /api/v2/main/auth/updatebrandbyid

const param = {
  "accountaddress": "string",
  "brandname": "string",
  "description": "string",
  "id": 0,
  "imgurl": "string",
  "ownername": "string"
}

return result = {
    code === 1: success
    code !== 0: error
}
```

**Update the brand background image**

```jsx
# POST
# /api/v2/main/auth/updatebandimg

const param = {
  "accountaddress": "string",
  "bandimgurl": "string",	// Update the background image's online link
  "id": 0
}

return result = {
    code === 1: success
    code !== 0: error
}
```





**Obtain brand information**

Gets a list of all brands created by a single user

```jsx
# POST
# /api/v2/main/auth/getaccountbrands

const params = {
    accountaddress : account
}

return result = {
    [brandArray] // Brand Information List
}
```



Single query: Gets the brand created by ID

```jsx
# POST
# /api/v2/main/auth/getbrandbyid

const params = {
    accountaddress : account, 
    id: 1 // brandID
}

return result = {
    Returns the brand details of the corresponding ID 
}
```

![image-20210403195321417](http://yitian-2020.oss-cn-shenzhen.aliyuncs.com/img/image-20210403195321417.png)



Bulk query: Get the brands created according to ID

```jsx
# POST
# /api/v2/main/auth/getbrandsbyfilter

const params = {
    accountaddress : account, 
    "brandcontractaddressess": [
        "0x1...", "0x2..."
     ],
    Category: String,	// optional
    channel: String	// optional
}

return result = {
    Returns a detailed list of brands corresponding to the ID list
}
```

**other**

> To get the Popular Brands information on the first page, this interface returns 6 brands and needs to filter the NFT of Brandid === 10 and Brandid === 11 of the bounce platform itself. These two brands are not included in the ranking

```jsx
# POST
# /api/v2/main/auth/getpopularbrands

const params = {
    accountaddress: account
}

return result = Array(4){
    // Brand Information List
}
```



#### 2.6 Like Item

> When browsing the market, users can add the items they are interested in to Like or cancel the items they were interested in before, and the items they have collected can be viewed in My Like

**添加挂单**

```jsx
# POST
# /api/v2/main/auth/dealaccountlike

const params = {
  "accountaddress": "string",	// Index by user account
  "auctiontype": 0,		// The type of item being sold，0：fixed-swap 1：english-auction
  "brandid": 0,		// Item corresponds to the ID of the brand
  "iflike": 0,	// 	Whether like 0: Cancel the like 1：like
  "itemid": 0,	//  item id
  "poolid": 0
}


return result = {
    code === 1: success
    code !== 0: error
}
```

**Get a list of like**

```jsx
# POST
# /api/v2/main/auth/getaccountlike


const params = {
  "accountaddress": "string"
}

const result = Array( lenght ){
    // A list of item information for like
}
```

#### 2.7 *Fuzzy search

> There is a search function in the menu bar, which allows you to search globally for all NFT, Brand and Account for sale. You can only enter the keyword of the fuzzy query, and then return the data of the three terms corresponding to the keyword. You can use the information of the term to assemble the data and then query, and get all the complete data items.

```jsx
# POST
# /api/v2/main/getbylikestr


const params = {
  "likestr": "string"
}

const result = data(Object){
    account: Array(),
    brands: Array(),
    items: Array()
}
```

#### 2.8  *Follow the artist

**Get the Follows information based on the AccountAddress**

> Find out which artists are followed by a particular address

```jsx
# POST
# /api/v2/main/auth/getaccountlike

const params = {
    "accountaddress": "string"
}

const result = [0x..., 0x..., ...]
```

**Add the Follow Artist feature**

>  can follow the artist's account

```jsx
# POST
# /api/v2/main/auth/dealaccountfollow


const params = {
  "accountaddress": "string",	// Address of the user
  "followaddress": "string",	// Address of the artist you are following
  "iffollow": 0					// Whether to follow 0：Cancel the following 1：To follow
}

const result = {
    success || error
}
```

Note: Before doing this function, you need to request the follower list first, get the artist to follow, and then judge whether the current artist is in the list. If not, set 'iffollow = 1' to mean new follower; if so, set 'iffollow = 0' to mean cancel follower

#### 2.9 *Query Banner information

> The background can choose to display an artist in the banner, and add weight to the artist's Pool in the sales state. The first page can display the top four pools of the artist's weight according to the weight

```jsx
# GET
# /api/v2/main/allbanners


const result = {
	"code": 1,
	"data": [
		{
			"id": 2,	// The artist ID
			"title": "t2",	// Display the main title in the banner
			"subhead": "sx2",	// Show in the banner subtitle
			"artistaddress": "0x891aab34cc082c0c7325c1349a2f9b815a4ad4a6",	// Artist Address
			"created_at": "2021-04-15T08:16:39Z",	// Creation time
			"updated_at": "2021-04-15T09:54:24Z"	// Last Updated Time
		}
	],
	"limit": 15,
	"offset": 0,
	"total": 1
}
```

Note: To complete this function, first of all, we need to select the artist's address as the filtering condition, request the weight of the artist pool, and then sort it according to the weight, and render the first four pools according to the UI

**Query pool weight**

```jsx
# POST
# /api/v2/main/auth/getpoolsinfo


const params = {
  "poolids": "Array", // [0,1,3,...]
  "standards": "Array" // [2,2,1,1...]	ERC-721:1 ERC-1155:2
}

const result = data(Object){
    data: [{
        poolid: 0,
        poolweight: 100,
        standard: 1		// ERC-721:1 ERC-1155:2
    },...]
}
```

#### 2.10 * List My NFT

> The address of external NFT contract can be submitted to the platform, and my warehouse section of the platform can display the list of NFTs submitted and immediately owned by the user. As long as one user has submitted the same contract, the NFT owned by all the users in their warehouse can be displayed

**Submission of New Contract**

```js
# POST
# /api/v2/main/auth/addcontract

const params = {
  "accountaddress": "address",	// Address of the user
  "contractaddress": "address"	// External NFT contract address
}

export result = 	{
    "code": 1,
    "msg": "ok"
}
```

Note: Different users can submit the same contract address repeatedly. The back end will indicate the existence of the contract, but the code value is 1, so no error will be displayed

**查看新合约列表**

```js
# POST
# /api/v2/main/getitemsext

const params = {
    "accountaddress": "address",	// Address of the user
}

export result = {
    [item, item, item ...]
    // The item returned here is slightly different from the standard MateData, but the main fields used are all in the first level
}
```

After the list function is added here, since TokenID cannot be guaranteed to be unique within the platform, so there are many interfaces involved in query item information, which need to pass in an additional contract address field, and locate an accurate item data through the contract address and TokenID.
For updates, see **2.2 Create Using NFT**

### 三、Contract operation

#### 3.1 Create ERC - 721

> To cast an ERC-721 NFT, a number of steps are required, requiring the cooperation of the back end and the contract end.
> This applies to GenRate NFT and Add Brand Item NFT
>
> To create ERC-721, call Backend 2.2 to generate MATedata data in format

Upon successful MateData generation, the back-end interface returns the three required fields

- expiredtime：A timestamp that reflects the time 10 minutes later
- id: NFT Token ID
- signaturestr: An encrypted string signed by an administrator account on the back end

```jsx
const BounceERC721WithSign_CT = getContract(library, BounceERC721WithSign.abi, getBounceERC721WithSign(chainId))

try {
	BounceERC721WithSign_CT.methods.mintUser(_nftId, _sign, _expiredtime).send({ from: account })
        .on('transactionHash', hash => {
            setOpen(false)
            // setBidStatus(pendingStatus)
            showTransferByStatus('pendingStatus')
        })
        .on('receipt', async (_, receipt) => {
            // console.log('bid fixed swap receipt:', receipt)
            // setBidStatus(successStatus)
            showTransferByStatus('successStatus')
            history.push("/MyBrands")
        })
        .on('error', (err, receipt) => {
            // setBidStatus(errorStatus)
            showTransferByStatus('errorStatus')
        })
} catch (error) {
    console.log('BounceERC721_CT.methods.mintUser', error)
}

```

#### 3.2 Create ERC - 1155

> ERC-1155 is created with several more parameters than ERC-721, and ERC-1155 has several special properties. This also applies to GenRate NFT and Add Brand Item NFT
>
> To create ERC-1155, call Backend 2.2 to generate MATEDATA data in the format

- expiredtime：A timestamp that reflects the time 10 minutes later
- id: NFT Token ID
- signaturestr: An encrypted string signed by an administrator account on the back end
- _data：NFT data, can pass 0 by default
- _amount：1155 relative to 721 is the concept of quantity, here pass the number （supply）of casting

```jsx
const BounceERC1155WithSign_CT = getContract(library, BounceERC1155WithSign.abi, getBounceERC1155WithSign(chainId))
const _amount = formData.Supply
const _data = 0 

try {
    BounceERC1155WithSign_CT.methods.mintUser(_nftId, _amount, _data, _sign,_expiredtime).send({ from: account })
        .on('transactionHash', hash => {
            setOpen(false)
            // setBidStatus(pendingStatus)
            showTransferByStatus('pendingStatus')
        })
        .on('receipt', async (_, receipt) => {
            // console.log('bid fixed swap receipt:', receipt)
            // setBidStatus(successStatus)
            showTransferByStatus('successStatus')
            history.push("/MyBrands")
        })
        .on('error', (err, receipt) => {
            // setBidStatus(errorStatus)
            showTransferByStatus('errorStatus')
        })
} catch (error) {
    console.log('BounceERC1155_CT.methods.mintUser', error)
}
```

#### 3.3 Create a subcontract in the Factory

> Factory can generate sub-contracts for each brand, and these sub-contracts have the same functions as Bounce NFT contracts, which can be cast, transferred, sold, etc...

**Create ERC-721 subcontract**

```jsx
const Factory_CT = getContract(library, BounceNFTFactory.abi, getNFTFactory(chainId))

Factory_CT.methods.createBrand721(_name, _symbol).send({ from: account })
```

- _name: Uniform name for the NFT cast
- _symbol: The NFT uniform symbol cast

**Create the ERC-1155 subcontract**

> The ERC-1155 contract does not have the concept of name and symbol, so it only needs to pass a baseURL

```jsx
const Factory_CT = getContract(library, BounceNFTFactory.abi, getNFTFactory(chainId))

Factory_CT.methods.createBrand1155(_uri).send({ from: account })
```



#### 3.4 Fixed-swap

##### a ) Selling the ERC - 721

> The essence of the sales operation is that the NFT in the account needs to be managed into the contract, and the Approve operation needs to be carried out first at this time

**approve**

```jsx
BounceERC721WithSign_CT.methods.approve(
    getFixedSwapNFT(chainId),
    parseInt(_tokenId)
).send({ from: account });
```

**send**

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))

BounceFixedSwapNFT_CT.methods.createErc721(_name, _token0, _token1, _tokenId, _amountTotal1, _onlyBot).send({ from: account })
```

- _name: NFT name
- _token0:   The contract address of the NFT for sale
- _token1:  The contract address of the collection subject (ETH, BNB) is 0x000...000).
- _tokenId: NFT ID for sale
- _amountTotla1: The selling price, and the units are token1 symbols
- _onlyBot: Is the participant a BOT (AUCTION) holder

##### b ) Selling the ERC - 1155

**approve**

```jsx
BounceERC1155WithSign_CT.methods.setApprovalForAll(
    getFixedSwapNFT(chainId),
    true
).send({ from: account });
```

**send**

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))

BounceFixedSwapNFT_CT.methods.createErc1155(_name, _token0, _token1, _tokenId, _amountTotal0,_amountTotal1, _onlyBot)
.send({ from: account })
```

- _name: NFT name
- _token0:   The contract address of the NFT for sale
- _token1:  The contract address of the collection subject (ETH, BNB) is 0x000...000).

- _tokenId: NFT ID for sale
- _amountTotal0: Number of NFTs to sell
- _amountTotla1: The total selling price, in symbols of Token 1
- _onlyBot: Is the participant a BOT (AUCTION) holder

##### c ) Buying Common Methods

> The pool ID is indexed from 0. The pool ID increases with each additional sales order in the fixed-swap pool. The pool ID is equal to the order number

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))


BounceFixedSwapNFT_CT.methods.swap(poolId, _amountTotal0)
.send(sendParams)
```

- poolId：The pool ID corresponding to the transaction
- _amountTotal0: The number of NFT to be purchased (the quantity of ERC-721 can only be 1, and ERC-1155 can be purchased in multiple times)

##### d ) Eliminate the common method of selling

> Fixed - Swap supports sellers to cancel the sale halfway

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))


BounceFixedSwapNFT_CT.methods.cancel(poolId)
.send(sendParams)
```

- pool Id：The pool ID corresponding to the transaction





#### 3.5 English-Auction

##### a ) General method of selling

**approve**

> If it is non-ETH, the base currency of BNB is used as the payment currency, which needs to be approved before consumption, and the platform adopts one-time authorization

```jsx
 const BounceERC20_CT = getContract(library, BounceERC20.abi, poolInfo.token1.contract)

BounceERC20_CT.methods.approve(getFixedSwapNFT(chainId), '0xffffffffffffffff')
.send({ from: account })
```



**send**

```jsx
const BounceEnglishAuctionNFT_CT = getContract(library, BounceEnglishAuctionNFT.abi, getEnglishAuctionNFT(chainId))

BounceEnglishAuctionNFT_CT.methods.createErc721(_name, _token0, _token1, _tokenId,
						_amountMax1, _amountMin1, _amountMinIncr1, _amountReserve1, _duration, _onlyBot).send({ from: account })
```

- name: NFT name
- _token0:   The contract address of the NFT for sale
- _token1: The contract address of the collection subject (ETH, BNB) is 0x000...000).

- _amountMax1: Direct Purchase Price, where the buyer can buy the item directly at the Price of one bid, bypassing the auction
- _amountMin1: Minimum Bid,The starting price of the item
- _amountMinIncr1: The lowest range of each mark-up
- _amountReserve1：Reserve price, the final bidding price is lower than this price will flow to auction
- _duration：Expriration Date
- _onlyBot:  Is the participant a BOT (AUCTION) holder



##### b ) General Method of Bidding

**approve**

> If it is non-ETH, the base currency of BNB is used as the payment currency, which needs to be approved before consumption, and the platform adopts one-time authorization

```jsx
 const BounceERC20_CT = getContract(library, BounceERC20.abi, poolInfo.token1.contract)

BounceERC20_CT.methods.approve(getFixedSwapNFT(chainId), '0xffffffffffffffff')
.send({ from: account })
```

**send**

> If a user's bid is higher than the lowest price range of the previous bid during the auction duration (higher than the starting price for the first time) and the price is less than the one bid price, it is a normal bidding action.
> At the end of the auction, if the highest bid is higher than the reserve price, the bid is successful.
> If it falls below the reserve price, it is a lost bid.
>
> Or, of course, you can just buy it at one price and skip the auction, and you end up with the pool.
>
> This auction method ERC-1155 does not support bidding by quantity, but can only be purchased in packages

```jsx
const BounceEnglishAuctionNFT_CT = getContract(library, BounceEnglishAuctionNFT.abi, getEnglishAuctionNFT(chainId))

BounceEnglishAuctionNFT_CT.methods.bid(poolId, _amount1)
.send(sendParams)
```

- pool Id：The pool ID corresponding to the transaction
- _amountTotal1: bid price

##### c ) Seller claim

> The item is successfully auctioned and the seller can take back the ERC-20 token paid by the buyer
>
> Items lost auction: The seller retrieves the NFT sold

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))


BounceFixedSwapNFT_CT.methods.bidderClaim(poolId)
.send(sendParams)
```

- pool Id：The pool ID corresponding to the transaction

##### d ) Buyers claim

> Successful bid: the buyer receives the NFT
>
> Auction failure: For example, if the bid does not reach the seller's reserve price, you can get your ERC-20 tokens back after the auction

```jsx
const BounceFixedSwapNFT_CT = getContract(library, BounceFixedSwapNFT.abi, getFixedSwapNFT(chainId))

BounceFixedSwapNFT_CT.methods.creatorClaim(poolId)
.send(sendParams)
```



### 四、The Graph

> Details see the DEMO

### 五、Page API Example

#### 5.1 Home

![image-20210408105353954](http://oss.yitian2019.cn/img/image-20210408105353954.png)

**Home-1**

1. First, use The Graph to request all the list data for sale.（tradePools, tradeAuctions）
2. Request the backend interface`/api/v2/main/getitemsbyfilter`，Gets the corresponding Item information
3.  Rendered the first eight data  sorted according to 'item.popular'

**Home-2**

1. Request the backend interface`/api/v2/main/getpopularbrands`，Find out the 6 most popular brands

note：brandId = 10 represent Bounce office 721 brand，brandId = 11 represent Bounce office 1155 brand，They don't participate in the rankings

#### 5.2 MarketPlace

![image-20210408115242563](http://oss.yitian2019.cn/img/image-20210408115242563.png)

**Show Item**

1. First, use The Graph to request all the list data for sale（tradePools, tradeAuctions）
2. Request the backend interface`/api/v2/main/getitemsbyfilter`，Gets the corresponding Item information

Note: The request backend interface can filter the query according to the Transfer Parameters Category and Channel type. See 2.2 for Creating Using NFT



#### 5.3 Brand List

![image-20210408120527223](http://oss.yitian2019.cn/img/image-20210408120527223.png)

**Show Item**

1. Start by using The Graph to request a list of all brands（bounce721Brands, bounce1155Brands）
2. Request the backend interface`/api/v2/main/getbrandsbyfilter`，Obtain the corresponding Brand Item information

#### 5.4 My Inventory

![image-20210408121315678](http://oss.yitian2019.cn/img/image-20210408121315678.png)

**Account-1**

1. Request the backend interface`/api/v2/main/auth/getaccount`
2. Modify information call interface`/api/v2/main/auth/updateaccount`
3. Update brand background image call interface`/api/v2/main/auth/updateaccountbandimg`

**My Inventory**

> My Inventory consists of the following data sources
>
> 1. The list of NFTs minted by the Bounce platform in the account
> 2. List of NFTs currently on sale in the account
> 3. NFT imported into Bounce by a third-party platform (not implemented)

- Inventory-1	（Data source 1）

1. According to the filter conditions, the account address requests theGraph to get the data of data source 1（nft721Items，nft1155Items）
2. Request backend interface`/api/v2/main/getitemsbyfilter`，Get the corresponding Item information

- Inventory-2	（Data source 2）

1. Request theGraph to get the data of data source 2 according to the account address（tradePools, tradeAuctions），Get the list of NFTs sold in the market for this account
2. Request backend interface`/api/v2/main/getitemsbyfilter`，Get the corresponding Item information

Note: The Graph can pass in the account address and state as the filter condition to get the data you want

#### 5.5 My Brand

![image-20210413161145442](http://oss.yitian2019.cn/img/image-20210413161145442.png)

**My Brand List**

- Request contract`Factory_CT.methods.brands(account).call()` Get the Brand address created by the current account
- Request backend interface`/api/v2/main/auth/getaccountbrands` Query the basic information parameters of the brand
- The two can be contacted and matched through `contractaddress`

**Change Brand Background**

1. Get the bandimgurl in the `/api/v2/main/auth/getaccount` interface as the picture setting
2. Request back-end interface `/api/v2/main/auth/updateaccountbandimg` to replace the image

**Create Brand**

![image-20210413164217214](http://oss.yitian2019.cn/img/image-20210413164217214.png)

1. The first step is to upload an image through `/api/v2/main/auth/fileupload` to generate an online image link
2. Call the factory contract `createBrand721`/`createBrand1155` to generate the brand sub-contract
3. After packaging the JSON data, request `/api/v2/main/auth/addbrand` to store brand information

**Brand Item List**

![image-20210413171548074](http://oss.yitian2019.cn/img/image-20210413171548074.png)

> My Brand Item List consists of the following data sources
>
> 1. The list of NFTs minted by this Brand platform in the account
> 2. The NFT created by this brand that is being sold in the account

- My Brand Item List（Data source 1）

1. According to the filter conditions user and contract, request theGraph to get the data of data source 1（nft721Items，nft1155Items）
2. Request backend interface`/api/v2/main/getitemsbyfilter`，Get the corresponding Item information

- My Brand Item List （Data source 2）

1. Request theGraph according to user and token0, and get the data of data source 2（tradePools, tradeAuctions），Get the list of NFTs created by this brand that this account is selling in the market
2. Request the back-end interface `/api/v2/main/getitemsbyfilter` to obtain the corresponding Item information

Note: The Graph can pass in account, token0 address, and state as filter conditions to get the data you want

#### 5.6 My Activited

![image-20210413172851994](http://oss.yitian2019.cn/img/image-20210413172851994.png)

1. First use the Graph to request all on-sale list data (activities)
2. Request the back-end interface `/api/v2/main/getitemsbyfilter` to obtain the corresponding Item information
3. Match the information and put it on the page for display

#### 5.7 My Liked

![image-20210413181951863](http://oss.yitian2019.cn/img/image-20210413181951863.png)

1. Request interface `/api/v2/main/auth/getaccountlike` to get the like list
2. Query the contract `BounceNFT.methods.pools.call(poolId)` according to poolID to get the price and other information of the pool

#### 5.8 Sell Page

![image-20210415174919707](http://oss.yitian2019.cn/img/image-20210415174919707.png)

>  Data source analysis (data source composed of this page)

#### 5.9 Buy Page

![image-20210413182556314](http://oss.yitian2019.cn/img/image-20210413182556314.png)

> Data source analysis (data source composed of this page)

#### 5.10 *new Fuzzy global search

![image-20210415180320307](http://oss.yitian2019.cn/img/image-20210415180320307.png)

>  There is a search function in the function bar, which can globally fuzzy search all NFTs, Brands and Accounts that are on sale. You only need to enter the fuzzy query keywords, and return the data of the three entries corresponding to the keywords. Information is data spliced and then queried to obtain all complete data items

1. Request interface `/api/v2/main/getbylikestr` to pass in search keywords (see 2.7 for details)
2. Account and brands data processing is relatively simple, only need to display and render the data items returned by the backend
3. Item data needs to find out the detailed information of the pool through The Graph to assemble the complete data item display

#### 5.11 Artist homepage function

> Display all NFT for sale by artists, not limited to brand creation or platform direct GenRate and external import

1. All the pools created by User can be found by passing user_account as an argument based on the https://api1-bsc.fangible.com/v1/bsc_test/pools interface
2. Carry out data cleaning, and filter out the NFT that is not sold in the market and some that do not meet the specifications
3. According to the situation to build params: {CTS, ids, cannel, category} request/API/v2 / main/getitemsbyfilter interface to get the data
4. Connect the data and render it on the page